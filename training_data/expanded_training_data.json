[
  {
    "description": "Crear un bucket S3 con versionado habilitado y encriptación",
    "terraform_code": "resource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-example-bucket\"\n  \n  versioning {\n    enabled = true\n  }\n  \n  server_side_encryption_configuration {\n    rule {\n      apply_server_side_encryption_by_default {\n        sse_algorithm = \"AES256\"\n      }\n    }\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con tipo t2.micro en la región us-east-1",
    "terraform_code": "resource \"aws_instance\" \"example\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  tags = {\n    Name = \"example-instance\"\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad que permite SSH desde cualquier IP",
    "terraform_code": "resource \"aws_security_group\" \"ssh\" {\n  name        = \"ssh-access\"\n  description = \"Permite acceso SSH\"\n  \n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear una VPC con subred pública y privada",
    "terraform_code": "resource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n  \n  tags = {\n    Name = \"main-vpc\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.1.0/24\"\n  \n  tags = {\n    Name = \"public-subnet\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.2.0/24\"\n  \n  tags = {\n    Name = \"private-subnet\"\n  }\n}"
  },
  {
    "description": "Crear un balanceador de carga de aplicación con listener HTTP",
    "terraform_code": "resource \"aws_lb\" \"example\" {\n  name               = \"example-alb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.alb.id]\n  subnets            = [aws_subnet.public.id]\n}\n\nresource \"aws_lb_listener\" \"example\" {\n  load_balancer_arn = aws_lb.example.arn\n  port              = \"80\"\n  protocol          = \"HTTP\"\n  \n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.example.arn\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con política de ciclo de vida para archivar objetos antiguos",
    "terraform_code": "resource \"aws_s3_bucket\" \"logs\" {\n  bucket = \"my-logs-bucket\"\n}\n\nresource \"aws_s3_bucket_lifecycle_configuration\" \"logs\" {\n  bucket = aws_s3_bucket.logs.id\n  \n  rule {\n    id     = \"archive-old-logs\"\n    status = \"Enabled\"\n    \n    expiration {\n      days = 90\n    }\n    \n    transition {\n      days          = 30\n      storage_class = \"STANDARD_IA\"\n    }\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con grupo de seguridad y par de claves",
    "terraform_code": "resource \"aws_key_pair\" \"deployer\" {\n  key_name   = \"deployer-key\"\n  public_key = file(\"~/.ssh/id_rsa.pub\")\n}\n\nresource \"aws_security_group\" \"web\" {\n  name        = \"web-sg\"\n  description = \"Security group for web servers\"\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  key_name      = aws_key_pair.deployer.key_name\n  security_groups = [aws_security_group.web.name]\n  \n  tags = {\n    Name = \"web-server\"\n  }\n}"
  },
  {
    "description": "Crear una base de datos RDS MySQL con respaldo automático",
    "terraform_code": "resource \"aws_db_instance\" \"default\" {\n  identifier     = \"mydb\"\n  engine         = \"mysql\"\n  engine_version = \"8.0\"\n  instance_class = \"db.t3.micro\"\n  allocated_storage = 20\n  storage_type      = \"gp2\"\n  \n  db_name  = \"mydb\"\n  username = \"admin\"\n  password = \"changeme\"\n  \n  backup_retention_period = 7\n  backup_window          = \"03:00-04:00\"\n  maintenance_window     = \"mon:04:00-mon:05:00\"\n  \n  skip_final_snapshot = true\n}"
  },
  {
    "description": "Crear un grupo de seguridad para base de datos que solo permite tráfico desde una VPC",
    "terraform_code": "resource \"aws_security_group\" \"db\" {\n  name        = \"database-sg\"\n  description = \"Security group for database\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port   = 3306\n    to_port     = 3306\n    protocol    = \"tcp\"\n    cidr_blocks = [aws_vpc.main.cidr_block]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear una tabla DynamoDB con clave de partición y clave de ordenación",
    "terraform_code": "resource \"aws_dynamodb_table\" \"users\" {\n  name     = \"users\"\n  hash_key = \"UserId\"\n  range_key = \"Timestamp\"\n  \n  attribute {\n    name = \"UserId\"\n    type = \"S\"\n  }\n  \n  attribute {\n    name = \"Timestamp\"\n    type = \"N\"\n  }\n  \n  billing_mode = \"PAY_PER_REQUEST\"\n  \n  tags = {\n    Name        = \"users-table\"\n    Environment = \"production\"\n  }\n}"
  },
  {
    "description": "Crear una función Lambda con rol IAM y permisos",
    "terraform_code": "resource \"aws_iam_role\" \"lambda_role\" {\n  name = \"lambda-execution-role\"\n  \n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action = \"sts:AssumeRole\"\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n    }]\n  })\n}\n\nresource \"aws_lambda_function\" \"test_lambda\" {\n  filename      = \"lambda_function.zip\"\n  function_name = \"test_lambda\"\n  role          = aws_iam_role.lambda_role.arn\n  handler       = \"index.handler\"\n  runtime       = \"python3.9\"\n}"
  },
  {
    "description": "Crear un CloudWatch log group para Lambda",
    "terraform_code": "resource \"aws_cloudwatch_log_group\" \"lambda_logs\" {\n  name              = \"/aws/lambda/test_lambda\"\n  retention_in_days = 14\n}"
  },
  {
    "description": "Crear un bucket S3 con bloqueo de acceso público",
    "terraform_code": "resource \"aws_s3_bucket\" \"private\" {\n  bucket = \"my-private-bucket\"\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"private\" {\n  bucket = aws_s3_bucket.private.id\n  \n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}"
  },
  {
    "description": "Crear una instancia EC2 con volumen EBS adicional",
    "terraform_code": "resource \"aws_instance\" \"app\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  root_block_device {\n    volume_type = \"gp3\"\n    volume_size = 20\n  }\n  \n  tags = {\n    Name = \"app-server\"\n  }\n}\n\nresource \"aws_ebs_volume\" \"data\" {\n  availability_zone = aws_instance.app.availability_zone\n  size              = 50\n  type              = \"gp3\"\n  \n  tags = {\n    Name = \"data-volume\"\n  }\n}\n\nresource \"aws_volume_attachment\" \"data\" {\n  device_name = \"/dev/sdf\"\n  volume_id   = aws_ebs_volume.data.id\n  instance_id = aws_instance.app.id\n}"
  },
  {
    "description": "Crear un Internet Gateway y asociarlo a una VPC",
    "terraform_code": "resource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"main-igw\"\n  }\n}"
  },
  {
    "description": "Crear una tabla de rutas para una subred pública",
    "terraform_code": "resource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n  \n  tags = {\n    Name = \"public-rt\"\n  }\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  subnet_id      = aws_subnet.public.id\n  route_table_id = aws_route_table.public.id\n}"
  },
  {
    "description": "Crear un grupo de auto-scaling con lanzamiento de instancias",
    "terraform_code": "resource \"aws_launch_template\" \"web\" {\n  name_prefix   = \"web-\"\n  image_id      = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  vpc_security_group_ids = [aws_security_group.web.id]\n}\n\nresource \"aws_autoscaling_group\" \"web\" {\n  name                = \"web-asg\"\n  vpc_zone_identifier = [aws_subnet.public.id]\n  target_group_arns   = [aws_lb_target_group.web.arn]\n  health_check_type   = \"ELB\"\n  \n  min_size         = 1\n  max_size         = 3\n  desired_capacity = 2\n  \n  launch_template {\n    id      = aws_launch_template.web.id\n    version = \"$Latest\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con notificaciones a Lambda",
    "terraform_code": "resource \"aws_s3_bucket\" \"uploads\" {\n  bucket = \"my-uploads-bucket\"\n}\n\nresource \"aws_s3_bucket_notification\" \"lambda_trigger\" {\n  bucket = aws_s3_bucket.uploads.id\n  \n  lambda_function {\n    lambda_function_arn = aws_lambda_function.processor.arn\n    events              = [\"s3:ObjectCreated:*\"]\n  }\n}"
  },
  {
    "description": "Crear un API Gateway REST API con integración Lambda",
    "terraform_code": "resource \"aws_api_gateway_rest_api\" \"api\" {\n  name        = \"my-api\"\n  description = \"My API Gateway\"\n}\n\nresource \"aws_api_gateway_resource\" \"proxy\" {\n  rest_api_id = aws_api_gateway_rest_api.api.id\n  parent_id   = aws_api_gateway_rest_api.api.root_resource_id\n  path_part   = \"{proxy+}\"\n}\n\nresource \"aws_api_gateway_method\" \"proxy\" {\n  rest_api_id   = aws_api_gateway_rest_api.api.id\n  resource_id   = aws_api_gateway_resource.proxy.id\n  http_method   = \"ANY\"\n  authorization = \"NONE\"\n}\n\nresource \"aws_api_gateway_integration\" \"lambda\" {\n  rest_api_id = aws_api_gateway_rest_api.api.id\n  resource_id = aws_api_gateway_method.proxy.resource_id\n  http_method = aws_api_gateway_method.proxy.http_method\n  \n  integration_http_method = \"POST\"\n  type                    = \"AWS_PROXY\"\n  uri                     = aws_lambda_function.api.invoke_arn\n}"
  },
  {
    "description": "Crear un CloudFront distribution con origen S3",
    "terraform_code": "resource \"aws_cloudfront_distribution\" \"s3_distribution\" {\n  origin {\n    domain_name = aws_s3_bucket.example.bucket_regional_domain_name\n    origin_id   = \"S3-${aws_s3_bucket.example.bucket}\"\n  }\n  \n  enabled             = true\n  is_ipv6_enabled     = true\n  default_root_object = \"index.html\"\n  \n  default_cache_behavior {\n    allowed_methods  = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\"]\n    cached_methods   = [\"GET\", \"HEAD\"]\n    target_origin_id = \"S3-${aws_s3_bucket.example.bucket}\"\n    \n    forwarded_values {\n      query_string = false\n      cookies {\n        forward = \"none\"\n      }\n    }\n    \n    viewer_protocol_policy = \"allow-all\"\n    min_ttl                = 0\n    default_ttl            = 3600\n    max_ttl                = 86400\n  }\n  \n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n  }\n  \n  viewer_certificate {\n    cloudfront_default_certificate = true\n  }\n}"
  },
  {
    "description": "Crear un Elastic IP y asociarlo a una instancia EC2",
    "terraform_code": "resource \"aws_eip\" \"web\" {\n  instance = aws_instance.web.id\n  domain   = \"vpc\"\n  \n  tags = {\n    Name = \"web-eip\"\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad que permite HTTP y HTTPS",
    "terraform_code": "resource \"aws_security_group\" \"web_traffic\" {\n  name        = \"web-traffic-sg\"\n  description = \"Allow HTTP and HTTPS traffic\"\n  \n  ingress {\n    description = \"HTTP\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  ingress {\n    description = \"HTTPS\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con configuración de CORS",
    "terraform_code": "resource \"aws_s3_bucket\" \"cors_bucket\" {\n  bucket = \"my-cors-bucket\"\n}\n\nresource \"aws_s3_bucket_cors_configuration\" \"cors_bucket\" {\n  bucket = aws_s3_bucket.cors_bucket.id\n  \n  cors_rule {\n    allowed_headers = [\"*\"]\n    allowed_methods = [\"GET\", \"PUT\", \"POST\"]\n    allowed_origins = [\"https://example.com\"]\n    expose_headers  = [\"ETag\"]\n    max_age_seconds = 3000\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con user data script para instalar software",
    "terraform_code": "resource \"aws_instance\" \"web_with_setup\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  user_data = <<-EOF\n              #!/bin/bash\n              yum update -y\n              yum install -y httpd\n              systemctl start httpd\n              systemctl enable httpd\n              EOF\n  \n  tags = {\n    Name = \"web-with-setup\"\n  }\n}"
  },
  {
    "description": "Crear un NAT Gateway para permitir que instancias privadas accedan a internet",
    "terraform_code": "resource \"aws_eip\" \"nat\" {\n  domain = \"vpc\"\n  \n  tags = {\n    Name = \"nat-eip\"\n  }\n}\n\nresource \"aws_nat_gateway\" \"main\" {\n  allocation_id = aws_eip.nat.id\n  subnet_id     = aws_subnet.public.id\n  \n  tags = {\n    Name = \"main-nat\"\n  }\n  \n  depends_on = [aws_internet_gateway.main]\n}\n\nresource \"aws_route_table\" \"private\" {\n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block     = \"0.0.0.0/0\"\n    nat_gateway_id = aws_nat_gateway.main.id\n  }\n  \n  tags = {\n    Name = \"private-rt\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con replicación a otra región",
    "terraform_code": "resource \"aws_s3_bucket\" \"source\" {\n  bucket = \"my-source-bucket\"\n}\n\nresource \"aws_s3_bucket\" \"destination\" {\n  bucket = \"my-destination-bucket\"\n  provider = aws.us-west-2\n}\n\nresource \"aws_s3_bucket_replication_configuration\" \"replication\" {\n  role   = aws_iam_role.replication.arn\n  bucket = aws_s3_bucket.source.id\n  \n  rule {\n    id     = \"replicate-all\"\n    status = \"Enabled\"\n    \n    destination {\n      bucket        = aws_s3_bucket.destination.arn\n      storage_class = \"STANDARD\"\n    }\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad para Redis ElastiCache",
    "terraform_code": "resource \"aws_security_group\" \"redis\" {\n  name        = \"redis-sg\"\n  description = \"Security group for Redis\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port   = 6379\n    to_port     = 6379\n    protocol    = \"tcp\"\n    cidr_blocks = [aws_vpc.main.cidr_block]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear un cluster ElastiCache Redis",
    "terraform_code": "resource \"aws_elasticache_subnet_group\" \"redis\" {\n  name       = \"redis-subnet-group\"\n  subnet_ids = [aws_subnet.private.id]\n}\n\nresource \"aws_elasticache_replication_group\" \"redis\" {\n  replication_group_id       = \"redis-cluster\"\n  description                = \"Redis cluster\"\n  node_type                  = \"cache.t3.micro\"\n  port                       = 6379\n  parameter_group_name       = \"default.redis7\"\n  num_cache_clusters         = 2\n  automatic_failover_enabled = true\n  subnet_group_name          = aws_elasticache_subnet_group.redis.name\n  security_group_ids         = [aws_security_group.redis.id]\n}"
  },
  {
    "description": "Crear un bucket S3 con logging habilitado",
    "terraform_code": "resource \"aws_s3_bucket\" \"logs\" {\n  bucket = \"my-logs-bucket\"\n}\n\nresource \"aws_s3_bucket\" \"main\" {\n  bucket = \"my-main-bucket\"\n}\n\nresource \"aws_s3_bucket_logging\" \"main\" {\n  bucket = aws_s3_bucket.main.id\n  \n  target_bucket = aws_s3_bucket.logs.id\n  target_prefix = \"log/\"\n}"
  },
  {
    "description": "Crear una instancia EC2 con múltiples interfaces de red",
    "terraform_code": "resource \"aws_instance\" \"multi_interface\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t3.medium\"\n  subnet_id     = aws_subnet.public.id\n  \n  network_interface {\n    device_index         = 0\n    network_interface_id = aws_network_interface.primary.id\n  }\n  \n  network_interface {\n    device_index         = 1\n    network_interface_id = aws_network_interface.secondary.id\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con website hosting configurado",
    "terraform_code": "resource \"aws_s3_bucket\" \"website\" {\n  bucket = \"my-website-bucket\"\n}\n\nresource \"aws_s3_bucket_website_configuration\" \"website\" {\n  bucket = aws_s3_bucket.website.id\n  \n  index_document {\n    suffix = \"index.html\"\n  }\n  \n  error_document {\n    key = \"error.html\"\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"website\" {\n  bucket = aws_s3_bucket.website.id\n  \n  block_public_acls       = false\n  block_public_policy     = false\n  ignore_public_acls      = false\n  restrict_public_buckets = false\n}"
  },
  {
    "description": "Crear un grupo de seguridad para permitir tráfico desde otro grupo de seguridad",
    "terraform_code": "resource \"aws_security_group\" \"app\" {\n  name        = \"app-sg\"\n  description = \"Security group for application\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port                = 8080\n    to_port                  = 8080\n    protocol                 = \"tcp\"\n    source_security_group_id = aws_security_group.alb.id\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con encriptación KMS",
    "terraform_code": "resource \"aws_kms_key\" \"s3\" {\n  description             = \"KMS key for S3 encryption\"\n  deletion_window_in_days = 10\n}\n\nresource \"aws_s3_bucket\" \"encrypted\" {\n  bucket = \"my-encrypted-bucket\"\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"encrypted\" {\n  bucket = aws_s3_bucket.encrypted.id\n  \n  rule {\n    apply_server_side_encryption_by_default {\n      kms_master_key_id = aws_kms_key.s3.arn\n      sse_algorithm     = \"aws:kms\"\n    }\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con IAM role para acceder a S3",
    "terraform_code": "resource \"aws_iam_role\" \"ec2_s3_role\" {\n  name = \"ec2-s3-role\"\n  \n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action = \"sts:AssumeRole\"\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"ec2.amazonaws.com\"\n      }\n    }]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"ec2_s3_policy\" {\n  name = \"ec2-s3-policy\"\n  role = aws_iam_role.ec2_s3_role.id\n  \n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Action = [\n        \"s3:GetObject\",\n        \"s3:PutObject\"\n      ]\n      Resource = \"arn:aws:s3:::my-bucket/*\"\n    }]\n  })\n}\n\nresource \"aws_iam_instance_profile\" \"ec2_s3_profile\" {\n  name = \"ec2-s3-profile\"\n  role = aws_iam_role.ec2_s3_role.name\n}\n\nresource \"aws_instance\" \"with_s3_access\" {\n  ami                  = \"ami-0c55b159cbfafe1f0\"\n  instance_type        = \"t2.micro\"\n  iam_instance_profile = aws_iam_instance_profile.ec2_s3_profile.name\n  \n  tags = {\n    Name = \"instance-with-s3-access\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con política de bucket que permite acceso público de lectura",
    "terraform_code": "resource \"aws_s3_bucket\" \"public_read\" {\n  bucket = \"my-public-read-bucket\"\n}\n\nresource \"aws_s3_bucket_policy\" \"public_read\" {\n  bucket = aws_s3_bucket.public_read.id\n  \n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Sid       = \"PublicReadGetObject\"\n      Effect    = \"Allow\"\n      Principal = \"*\"\n      Action    = \"s3:GetObject\"\n      Resource  = \"${aws_s3_bucket.public_read.arn}/*\"\n    }]\n  })\n}"
  },
  {
    "description": "Crear una instancia EC2 con múltiples volúmenes EBS con diferentes tipos",
    "terraform_code": "resource \"aws_instance\" \"multi_volume\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  root_block_device {\n    volume_type = \"gp3\"\n    volume_size = 30\n    encrypted   = true\n  }\n  \n  ebs_block_device {\n    device_name = \"/dev/sdf\"\n    volume_type = \"io1\"\n    volume_size = 100\n    iops        = 1000\n    encrypted   = true\n  }\n  \n  ebs_block_device {\n    device_name = \"/dev/sdg\"\n    volume_type = \"gp3\"\n    volume_size = 50\n  }\n  \n  tags = {\n    Name = \"multi-volume-instance\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con transfer acceleration habilitado",
    "terraform_code": "resource \"aws_s3_bucket\" \"accelerated\" {\n  bucket = \"my-accelerated-bucket\"\n}\n\nresource \"aws_s3_bucket_acceleration_configuration\" \"accelerated\" {\n  bucket = aws_s3_bucket.accelerated.id\n  status = \"Enabled\"\n}"
  },
  {
    "description": "Crear un grupo de seguridad con reglas de ingress y egress específicas para PostgreSQL",
    "terraform_code": "resource \"aws_security_group\" \"postgres\" {\n  name        = \"postgres-sg\"\n  description = \"Security group for PostgreSQL database\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    description     = \"PostgreSQL\"\n    from_port       = 5432\n    to_port         = 5432\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.app.id]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"postgres-security-group\"\n  }\n}"
  },
  {
    "description": "Crear una instancia RDS PostgreSQL con respaldo y snapshots",
    "terraform_code": "resource \"aws_db_subnet_group\" \"postgres\" {\n  name       = \"postgres-subnet-group\"\n  subnet_ids = [aws_subnet.private.id]\n  \n  tags = {\n    Name = \"PostgreSQL subnet group\"\n  }\n}\n\nresource \"aws_db_instance\" \"postgres\" {\n  identifier     = \"postgres-db\"\n  engine         = \"postgres\"\n  engine_version = \"15.4\"\n  instance_class = \"db.t3.micro\"\n  allocated_storage = 20\n  storage_type      = \"gp2\"\n  \n  db_name  = \"mydb\"\n  username = \"postgres\"\n  password = \"changeme\"\n  \n  db_subnet_group_name   = aws_db_subnet_group.postgres.name\n  vpc_security_group_ids = [aws_security_group.postgres.id]\n  \n  backup_retention_period = 7\n  backup_window          = \"03:00-04:00\"\n  maintenance_window     = \"mon:04:00-mon:05:00\"\n  \n  skip_final_snapshot = true\n  \n  tags = {\n    Name = \"postgres-database\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de configuración de notificación de eventos",
    "terraform_code": "resource \"aws_s3_bucket\" \"events\" {\n  bucket = \"my-events-bucket\"\n}\n\nresource \"aws_s3_bucket_notification\" \"bucket_notification\" {\n  bucket = aws_s3_bucket.events.id\n  \n  eventbridge = true\n}"
  },
  {
    "description": "Crear una instancia EC2 con placement group",
    "terraform_code": "resource \"aws_placement_group\" \"cluster\" {\n  name     = \"cluster-pg\"\n  strategy = \"cluster\"\n}\n\nresource \"aws_instance\" \"cluster\" {\n  ami             = \"ami-0c55b159cbfafe1f0\"\n  instance_type   = \"t2.micro\"\n  placement_group = aws_placement_group.cluster.name\n  \n  tags = {\n    Name = \"cluster-instance\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de inventario configurado",
    "terraform_code": "resource \"aws_s3_bucket\" \"inventory\" {\n  bucket = \"my-inventory-bucket\"\n}\n\nresource \"aws_s3_bucket\" \"destination\" {\n  bucket = \"inventory-destination\"\n}\n\nresource \"aws_s3_bucket_inventory\" \"inventory\" {\n  bucket = aws_s3_bucket.inventory.id\n  name   = \"entire-bucket-inventory\"\n  \n  included_object_versions = \"All\"\n  \n  schedule {\n    frequency = \"Weekly\"\n  }\n  \n  destination {\n    bucket {\n      bucket_arn = aws_s3_bucket.destination.arn\n      format      = \"CSV\"\n      prefix      = \"inventory\"\n    }\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad para permitir tráfico desde una IP específica",
    "terraform_code": "resource \"aws_security_group\" \"restricted\" {\n  name        = \"restricted-sg\"\n  description = \"Security group with IP restriction\"\n  \n  ingress {\n    description = \"SSH from office\"\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"203.0.113.0/24\"]\n  }\n  \n  ingress {\n    description = \"HTTPS from office\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"203.0.113.0/24\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con metadata options configuradas",
    "terraform_code": "resource \"aws_instance\" \"with_metadata\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  metadata_options {\n    http_endpoint               = \"enabled\"\n    http_tokens                 = \"required\"\n    http_put_response_hop_limit = 1\n    instance_metadata_tags      = \"enabled\"\n  }\n  \n  tags = {\n    Name = \"instance-with-metadata\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de análisis configurado",
    "terraform_code": "resource \"aws_s3_bucket\" \"analytics\" {\n  bucket = \"my-analytics-bucket\"\n}\n\nresource \"aws_s3_bucket_analytics_configuration\" \"analytics\" {\n  bucket = aws_s3_bucket.analytics.id\n  name   = \"entire-bucket-analytics\"\n  \n  storage_class_analysis {\n    data_export {\n      destination {\n        s3_bucket_destination {\n          bucket_arn = aws_s3_bucket.destination.arn\n          format     = \"CSV\"\n          prefix     = \"analytics\"\n        }\n      }\n    }\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad con self reference para permitir comunicación entre instancias del mismo grupo",
    "terraform_code": "resource \"aws_security_group\" \"cluster\" {\n  name        = \"cluster-sg\"\n  description = \"Security group for cluster nodes\"\n  \n  ingress {\n    description = \"Allow all traffic from same security group\"\n    from_port   = 0\n    to_port     = 65535\n    protocol    = \"tcp\"\n    self        = true\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con monitoring detallado habilitado",
    "terraform_code": "resource \"aws_instance\" \"monitored\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  monitoring = true\n  \n  tags = {\n    Name = \"monitored-instance\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de request payment configurado",
    "terraform_code": "resource \"aws_s3_bucket\" \"requester_pays\" {\n  bucket = \"my-requester-pays-bucket\"\n}\n\nresource \"aws_s3_bucket_request_payment_configuration\" \"requester_pays\" {\n  bucket = aws_s3_bucket.requester_pays.id\n  payer  = \"Requester\"\n}"
  },
  {
    "description": "Crear una instancia EC2 con tenancy dedicada",
    "terraform_code": "resource \"aws_instance\" \"dedicated\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  tenancy       = \"dedicated\"\n  \n  tags = {\n    Name = \"dedicated-instance\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de ownership controls",
    "terraform_code": "resource \"aws_s3_bucket\" \"ownership\" {\n  bucket = \"my-ownership-bucket\"\n}\n\nresource \"aws_s3_bucket_ownership_controls\" \"ownership\" {\n  bucket = aws_s3_bucket.ownership.id\n  \n  rule {\n    object_ownership = \"BucketOwnerPreferred\"\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad con prefix list como origen",
    "terraform_code": "resource \"aws_security_group\" \"prefix_list\" {\n  name        = \"prefix-list-sg\"\n  description = \"Security group using prefix list\"\n  \n  ingress {\n    description     = \"HTTPS from prefix list\"\n    from_port       = 443\n    to_port         = 443\n    protocol        = \"tcp\"\n    prefix_list_ids = [aws_ec2_managed_prefix_list.example.id]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con capacity reservation",
    "terraform_code": "resource \"aws_ec2_capacity_reservation\" \"reservation\" {\n  instance_type     = \"t2.micro\"\n  instance_platform = \"Linux/UNIX\"\n  availability_zone  = \"us-east-1a\"\n  instance_count    = 1\n  end_date_type      = \"unlimited\"\n}\n\nresource \"aws_instance\" \"with_reservation\" {\n  ami                      = \"ami-0c55b159cbfafe1f0\"\n  instance_type            = \"t2.micro\"\n  capacity_reservation_specification {\n    capacity_reservation_preference = \"open\"\n  }\n  \n  tags = {\n    Name = \"instance-with-reservation\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de versioning y MFA delete",
    "terraform_code": "resource \"aws_s3_bucket\" \"mfa_versioned\" {\n  bucket = \"my-mfa-versioned-bucket\"\n}\n\nresource \"aws_s3_bucket_versioning\" \"mfa_versioned\" {\n  bucket = aws_s3_bucket.mfa_versioned.id\n  \n  versioning_configuration {\n    status     = \"Enabled\"\n    mfa_delete = \"Enabled\"\n    mfa        = \"${aws_iam_user.user.arn} ${aws_iam_virtual_mfa_device.device.serial_number}\"\n  }\n}"
  },
  {
    "description": "Crear un grupo de seguridad para permitir tráfico ICMP",
    "terraform_code": "resource \"aws_security_group\" \"icmp\" {\n  name        = \"icmp-sg\"\n  description = \"Security group allowing ICMP\"\n  \n  ingress {\n    description = \"ICMP\"\n    from_port   = -1\n    to_port     = -1\n    protocol    = \"icmp\"\n    cidr_blocks = [\"10.0.0.0/8\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
  },
  {
    "description": "Crear una instancia EC2 con hibernation habilitada",
    "terraform_code": "resource \"aws_instance\" \"hibernating\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t3.micro\"\n  \n  hibernation = true\n  \n  root_block_device {\n    volume_type = \"gp3\"\n    volume_size = 20\n  }\n  \n  tags = {\n    Name = \"hibernating-instance\"\n  }\n}"
  },
  {
    "description": "Crear un bucket S3 con objeto de public access block y bucket policy",
    "terraform_code": "resource \"aws_s3_bucket\" \"secure\" {\n  bucket = \"my-secure-bucket\"\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"secure\" {\n  bucket = aws_s3_bucket.secure.id\n  \n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_policy\" \"secure\" {\n  bucket = aws_s3_bucket.secure.id\n  \n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Deny\"\n      Principal = \"*\"\n      Action    = \"s3:*\"\n      Resource  = [\n        aws_s3_bucket.secure.arn,\n        \"${aws_s3_bucket.secure.arn}/*\"\n      ]\n      Condition = {\n        Bool = {\n          \"aws:SecureTransport\" = \"false\"\n        }\n      }\n    }]\n  })\n}"
  }
]
